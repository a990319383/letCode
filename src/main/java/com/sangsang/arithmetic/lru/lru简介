https://mp.weixin.qq.com/s/F5z4_CWmvc_s3Aly3eb6aQ
Least Recently Used
1.lru算法介绍：
最近最少使用算法，保留最近使用的数据，淘汰很久不使用的数据
方案一：数组 （时间复杂度O(n)）
    给定一个定长数组，数组中的每个元素设定一个自增的标识或者时间戳，每访问一次就维护一次这个标识，将最旧的数据进行替换
    每次操作都需要遍历数组进行维护新旧数据的标识，很蠢
方案二：链表（时间复杂度O(n)）
    每次访问数据的时候将最新访问的数据移动到链表末尾，这样链表头部的节点就是最少使用的
    当数据长度超出后将头部节点进行移除即可
    当有访问数据不在链表中时
        1.链表长度饱和：将头部的移除，将新数据节点拼接在末尾
        2.链表长度还有富余：直接拼接在末尾
    缺点：每次操作需要遍历链表，判断该节点是否存在，时间复杂度O(n)
方案三：双向链表+哈希表 (时间复杂度O(1))
    需求分析：
        1.有访问时序，能区分数据的访问新旧 (链表)
        2.能快速通过key 定位value   (HashMap)
        3.每次访问数据能快速将该数据设置为最新数据(支持任意位置快速删除，插入)
    现成的数据结构：LinkedHashMap
    大致数据结构
        node节点属性：key,value
        HashMap<key,node> key是数据的key，value存储的是链表的节点
        双向链表：存储每个node
    结构介绍：
        1.通过hashMap通过key可以快速定位访问的节点是否存在
        2.为什么hashMap中需要存储node对象，不直接存储value:存储node对象可以直接定位到该对象的前置节点和后置节点，然后方便将当前节点移除
        3.为什么是双向链表：定位到node对象可以直接定位到改节点的前置节点和后置节点，然后将定位的这个前置节点和后置节点连接起来，将访问到的node对象放到链表后即可
2.innodb的缓存的LRU算法
    innodb的有个缓存区Innodb_buffer_pool，当读取数据时，就会先从缓存中查看是否数据的页（page）存在，不存在的话才去磁盘上检索，查到后缓存到这个pool里。同理，插入、修改、删除也是先操作缓存里数据，之后再以一定频率更新到磁盘上
    一般情况innodb_buffer_pool_size 都会小于磁盘的数据量
    当buffer_pool满了之后，从磁盘读取一个数据页这时候就需要淘汰旧的数据页
    这里采用的是一个类似的LRU算法
传统的LRU算法不适用的原因：
    查询时候如果进行了全表扫描的话会将一些根本不常使用的数据进行缓存，可能误伤淘汰一些热点数据
解决方案：
    将整个LRU链表进行分区，按照5:3 的比例 分成young 区域和 old 区域
    从链表头部开始算，前5/8是young区，后3/8是old区
    访问young区的数据页：直接将该节点移动到链表头部
    访问链表不存在的数据页：新插入数据页存放于old区
    访问old区的数据页：
        1.判断这个数据页是否在链表中存在了1s，如果存在时间大于1s则将该节点移动到链表头部
        2.如果时间短于1s，则位置不变（1s这个参数由innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒）
全表扫描的时候：
    全表扫描的时候，一个数据页里面有多条数据，这个数据页会被多次访问到，但是顺序扫描，这个数据页被访问的前后间隔不会超过1s,这个数据页就会一直待在old区，等着被淘汰
3.redis的LRU算法
    todo